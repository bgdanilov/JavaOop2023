import java.util.Objects;

public class MyEquals {
    public static void main(String[] args) {
        // 1. По умолчанию, в классе Object, метод
        // equals(Object o) просто проверяет равенство ссылок при помощи ==
        // 2. Многие стандартные классы, такие как String, переопределяют метод equals,
        // чтобы он сравнивал содержимое объектов
        // 3. Поэтому в своих классах, если мы хотим сравнивать их объекты,
        // нужно переопределить метод equals

        B b1 = new B(1);
        B b2 = new B(1);

        A a1 = new A(2, b1);
        A a2 = new A(2, b1);
        A a3 = new A(2, b2);

        System.out.println(a1.equals(a2)); // true
        System.out.println(a1.equals(a3)); // false поля одинаковы, но b1 != b2.

    }

    // Некий класс A, полем которого является объект класса B.
    public static class A {
        private final int x;
        private final B y;

        public A(int x, B y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public boolean equals(Object o) {
            // 1. Проверка что ссылка оббъекта o и текущего - одна и та же.
            // Т.е. он равен сам себе.
            if (o == this) {
                return true;
            }
            // 2. Проверяем на null.
            // 2.1. Если нам передали вместо объекта null, то false.
            // 2.2. Сравниваются классы текущего объекта и переданного o.
            // Классы сравниваются по сслыке потому, что у объектов одного класса,
            // объект "класс" - один и тот же. Если ссылки разнее, то это уже разные классы.
            // Есть такой класс класс. getClass() его выдает.
            // Проверить!!!
            if (o == null || this.getClass() != o.getClass()) {
                return false;
            }
            // 3.
            // 3.1 Приводим объект к типу A. Что это значит?
            // Т.к. в equals мы передаем o - объект класса Objects,
            // а мы хотим сравнить с объектом класса A,
            // то нужно явно привести объект o класса к классу A, чтобы его передать в метод.
            // Это мы можем сделать, т.е. A наследован от Objects.
            A pair = (A) o;
            // 3.2. Сравниваем поля.
            // y может быть null. Надо учесть.
            // Для этого используем Objects.equals(y, a.y)
            // - сравнивает ссылки и сам учитывает null'ы:
            //   если первый переданный объект null, будет false/
            //   иначе, вызызывается equals.
            return this.x == pair.x && Objects.equals(this.y, pair.y);
        }
    }

    // Некий класс B, объект которого является полем класса A.
    public static class B {
        private final int y;

        public B(int y) {
            this.y = y;
        }
    }
}

/**
 * 1. Рефлексивность: Объект должен равняться себе самому.
 * 2. Симметричность: если a.equals(b) возвращает true, то b.equals(a) должен тоже вернуть true.
 * 3. Транзитивность: если a.equals(b) возвращает true и b.equals(c) тоже возвращает true,
 * то c.equals(a) тоже должен возвращать true.
 * 4. Согласованность: повторный вызов метода equals() должен возвращать
 * одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено.
 * То есть, если два объекта равны в Java, то они будут равны пока их свойства остаются неизменными.
 * 5. Сравнение null: объект должны быть проверен на null.
 * Если объект равен null, то метод должен вернуть false, а не NullPointerException.
 * Например, a.equals(null) должен вернуть false.
 */